\chapter{Implementation}

\section{Overview}

This chapter describes the changes and enhancements that were made to
Elektra in order to answer the research questions.
First we talk about Elektra's plugin API in general and how we used it
to introduce cryptographic operations to Elektra. Then the concept of
the key management is presented. At last some interesting implementation
details about the crypto libraries used are given.

\section{Elektra Plugins}\label{elektra-plugins}

Elektra abstracts configuration parameters in a hierarchical key-value
database. A keyset holds zero or more keys. The keyâ€š holds the
configuration parameter either as a string value or as a binary value.

The core of Elektra is kept small, meaning that it provides mainly the
database abstraction as well as a plugin system. All the configuration
access operations (mainly file reads and writes but there are more
complicated constructs, like intercepting \texttt{open()} calls in
order to inject a Mozilla configuration, as well) are performed by
plugins. The plugins should fulfill exactly one purpose, keeping to the
UNIX philosophy. To give an example: one plugin may write to
\texttt{/etc/hosts} and another one may encode binary values using the
Base64 encoding scheme.

Backends are one or more plugins combined into a unit that interact with a single configuration point (typically a configuration file).
The backend is ''mounted`` into Elektra's configuration hierachy.
This process is similar to the mounting process in UNIX-like file systems, where a device can be mounted to a specific directory in the virtual file system.
In terms of Elektra the virtual file system is the key-value database and the device is the configuration file.
Every backend has its own configuration itself, which specifies the runtime behavior of the plugins within the backend.

A plugin can export different methods in order to fulfill its purpose.
They are enumerated below:

\subsection{checkconf}\label{checkconf}

At this stage a plugin may validate the backend configuration as well as
the plugin configuration. The plugin may modify the configuration or
report that the configuration is incomplete or wrong in some way.

\subsection{open}\label{open}

The \texttt{open} stage is called to initialize the plugin.

\subsection{close}\label{close}

The \texttt{close} stage is called to properly shutdown the plugin and
release all resources it may hold.

\subsection{set}\label{set}

The \texttt{set} stage is called when changes made to the key-value
database should be persisted.

\subsection{get}\label{get}

The \texttt{get} stage is called when the content of the key-value
database is requested by an application.

\section{Crypto Plugin}\label{crypto-plugin}

To protect confidential values within a configuration set the
\texttt{crypto} plugin encrypts values at the \texttt{set} stage and
decrypts them at the \texttt{get} stage.

The crypto plugin only processes Elektra Keys which have a meta-key
\texttt{crypto/encrypt} set to ``1''.

The Advanced Encryption Standard (AES) cipher with 256 bit key-length in
Cipher Block Chaining (CBC) mode is used for symmetric encryption and
decryption.

Since the crypto Plugin can be easily enabled and disabled just by adding it to an Elektra backend,
it will be very easy to benchmark its performance impact later on.

\subsection{Details About The Crypto
Libraries}\label{details-about-the-crypto-libraries}

In order to benchmark different crypto provider there are three compile
variants of the crypto plugin, each using a different provider:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \texttt{crypto\_botan} using the Botan library
\item
  \texttt{crypto\_openssl} using \texttt{libcrypto} (a part of the
  OpenSSL library)
\item
  \texttt{crypto\_gcrypt} using GPG's \texttt{libgcrypt}
\end{enumerate}

\subsection{Key Management}\label{key-management}

The crypto plugin uses GnuPG for handling cryptographic keys. The
GPG-keys to use for encryption are specified in the plugin
configuration.

When a backend is mounted with the crypto plugin (see
\texttt{checkconf}) a random character string called the \emph{master
password} is generated. The master password is encrypted by calling
GnuPG and the encrypted master password is stored in the plugin
configuration.

If the plugin wants to encrypt a value, it reads the encrypted master
password from the configuration and decrypts it by calling GnuPG. Then a
salt is generated for the Elektra-Key holding the value. Together with
the master password the PBKDF2 is called to generate a cryptographic key
as well as an initialization vector (IV).

The generated cryptographic key together with the IV are passed on to
the crypto provider.

\section{Fcrypt Plugin}\label{fcrypt-plugin}

The \texttt{fcrypt} plugin was written to encrypt and decrypt whole
files using the GPG interface mentioned before. One of its advantages is
that it requires the \texttt{gpg2} or \texttt{gpg} binary as only
runtime dependency. There are no dependencies at compile time.

Again the GPG keys to be used for encryption are defined in the plugin
configuration following the same semantics as the \texttt{crypto}
plugins do.

This chapter explained the Elektra plugin system and how we used it to introduce cryptographic methods to the Elektra project.
Now that we have an application to examine, we continue with the description of the actual measurements in the following chapter.
