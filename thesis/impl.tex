\chapter{Implementation}

\section{Overview}

This chapter describes the changes and enhancements that were made to
Elektra in order to answer the research questions.
First we talk about Elektra's plugin API in general and how we used it
to introduce cryptographic operations to Elektra. Then the concept of
the key management is presented. At last some interesting implementation
details about the crypto libraries used are given.

\section{Elektra Plugins}\label{elektra-plugins}

Elektra abstracts configuration parameters in a hierarchical key-value database.
A keyset holds zero or more keys.
The key holds its path within the configuration hierarchy as well as the configuration parameter either as a string value or as a binary value.
A key may also contain meta-keys, which are keys that further describe the key.
Elektra uses meta-keys for different purposes:

\begin{enumerate}
\item state information of the key (e.g. encrypted, encoded, ...)
\item data validation (e.g. numeric value, binary value, ...)
\item formatting (e.g. position in file, number of spaces/tabs between parameters, ...)
\end{enumerate}

The core of Elektra is kept small, meaning that it provides mainly the
database abstraction as well as a plugin system. All the configuration
access operations (mainly file reads and writes but there are more
complicated constructs, like intercepting \texttt{open()} calls in
order to inject a Mozilla configuration, as well) are performed by
plugins. The plugins should fulfill exactly one purpose, keeping to the
UNIX philosophy. To give an example: one plugin may write to
\texttt{/etc/hosts} and another one may encode binary values using the
Base64 encoding scheme.

Backends are one or more plugins combined into a unit that interact with a single configuration point (typically a configuration file).
The backend is ''mounted`` into Elektra's configuration hierachy.
This process is similar to the mounting process in UNIX-like file systems, where a device can be mounted to a specific directory in the virtual file system.
In terms of Elektra the virtual file system is the key-value database and the device is the configuration file.
Every backend has its own configuration itself (i.e. backend configuration), which specifies the runtime behavior of the plugins within the backend.

Elektra's build scripts provide a functionality called compile variants, which means a plugin is being compiled multiple times with minor differences.
This is useful if a feature (e.g. cryptographic operations) is provided by different libraries interchangeably.
A lot of the plugin code stays the same for every compile variant except for the library-specific calls.
Those calls are encapsulated using C preprocessor directives.
The following code snippet illustrates compile variants further:

\begin{lstlisting}[language=C]
static int elektraCryptoInit (Key * errorKey)
{
#if defined(ELEKTRA_CRYPTO_API_GCRYPT)
	return elektraCryptoGcryInit (errorKey);
#elif defined(ELEKTRA_CRYPTO_API_OPENSSL)
	return elektraCryptoOpenSSLInit (errorKey);
#elif defined(ELEKTRA_CRYPTO_API_BOTAN)
	return elektraCryptoBotanInit (errorKey);
#else
	return 1;
#endif
}
\end{lstlisting}

As we can see every crypto library is handled differently but the code frame of the plugin stays the same for all compile variants.

A plugin can export different methods in order to fulfill its purpose.
They are enumerated below:

\subsection{checkconf}\label{checkconf}

At this method a plugin may validate the backend configuration as well as
the plugin configuration. The plugin may modify the configuration or
report that the configuration is incomplete or wrong in some way.

\subsection{open}\label{open}

The \texttt{open} method is called to initialize the plugin.

\subsection{close}\label{close}

The \texttt{close} method is called to properly shutdown the plugin and
release all resources it may hold.

\subsection{set}\label{set}

For storage plugins the \texttt{set} method is called when changes made to the key-value
database should be persisted.
Filter plugins export this method to modify the keyset (e.g. encode binary values using the Base64 schema).

\subsection{get}\label{get}

The \texttt{get} method is called when the content of the key-value
database is requested by an application.
Filter plugins provide this method to transform data in the keyset (e.g. decoding Base64 encoded strings back into their corresponding binary value).
Storage plugins typically perform read operations within this method.

\section{Crypto Plugin}\label{crypto-plugin}

To protect confidential values within a configuration set the
\texttt{crypto} plugin encrypts values at the \texttt{set} method and
decrypts them at the \texttt{get} method.

The crypto plugin only processes Elektra Keys which have a meta-key
\texttt{crypto/encrypt} set to ``1''.

The Advanced Encryption Standard (AES) cipher with 256 bit key-length in
Cipher Block Chaining (CBC) mode is used for symmetric encryption and
decryption.

Since the crypto Plugin can be easily enabled and disabled just by adding it to an Elektra backend,
it will be very easy to benchmark its performance impact later on.

\subsection{Details About The Crypto
Libraries}\label{details-about-the-crypto-libraries}

In order to benchmark different crypto provider there are three compile
variants of the crypto plugin, each using a different provider:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \texttt{crypto\_botan} using the Botan library
\item
  \texttt{crypto\_openssl} using \texttt{libcrypto} (a part of the
  OpenSSL library)
\item
  \texttt{crypto\_gcrypt} using GPG's \texttt{libgcrypt}
\end{enumerate}

\subsection{Key Management}\label{key-management}

The crypto plugin uses GnuPG for handling cryptographic keys. The
GPG-keys to use for encryption are specified in the backend
configuration.

When a backend is mounted with the crypto plugin (see
\texttt{checkconf}) a random character string called the \emph{master
password} is generated. The master password is encrypted by calling
GnuPG and the encrypted master password is stored in the plugin
configuration.

If the plugin wants to encrypt a value, it reads the encrypted master
password from the configuration and decrypts it by calling GnuPG. Then a
salt is generated for the Elektra-Key holding the value. Together with
the master password the PBKDF2 is called to generate a cryptographic key
as well as an initialization vector (IV).

The generated cryptographic key together with the IV are passed on to
the crypto library.

\section{Fcrypt Plugin}\label{fcrypt-plugin}

The \texttt{fcrypt} plugin was written to encrypt and decrypt whole files using the GPG interface mentioned before.
One of its advantages is that there are no dependencies at compile time.
Only the \texttt{gpg2} or \texttt{gpg} binary are required as runtime dependency.

Again the GPG keys to be used for encryption are defined in the plugin configuration following the same semantics as the \texttt{crypto} plugins.

This chapter explained the Elektra plugin system and how we used it to introduce cryptographic methods to the Elektra project.
Now that we have an application to examine, we continue with the description of the actual measurements in the following chapter.
